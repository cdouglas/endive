[simulation]
# Simulation duration in milliseconds
duration_ms = 100000000
# Output file path (parquet format)
output_path = "results.parquet"
# Random seed (omit for random seed)
# seed = 42

[experiment]
# Optional experiment label for organized output
# When set, output goes to: experiments/$label-$hash/$seed/results.parquet
# where $hash is deterministic based on config + simulator code
# label = "baseline"

[catalog]
num_tables = 10

# Table grouping configuration
# num_groups: Number of table groups (default: 1 for no grouping)
# When num_groups = num_tables, conflicts only at table level
# When num_groups < num_tables, tables are partitioned into groups
# Transactions never span groups
num_groups = 1

# Group size distribution: "uniform" or "longtail"
# uniform: all groups approximately the same size
# longtail: one large group, few medium groups, long tail of small groups
group_size_distribution = "uniform"

# For longtail distribution:
# large_group_fraction: fraction of tables in the largest group (e.g., 0.5)
# medium_groups_count: number of medium-sized groups (e.g., 3)
# medium_group_fraction: fraction of remaining tables in medium groups (e.g., 0.3)
# The rest are divided into small groups
longtail.large_group_fraction = 0.5
longtail.medium_groups_count = 3
longtail.medium_group_fraction = 0.3

[transaction]
retry = 10
# Transaction runtime distribution (lognormal)
runtime.min = 5000
runtime.mean = 10000
runtime.sigma = 1.5

# Inter-arrival time distribution
# distribution: "fixed", "exponential", "uniform", "normal"
inter_arrival.distribution = "exponential"
# For exponential: scale parameter (mean = scale)
inter_arrival.scale = 5000.0
# For uniform: [min, max]
inter_arrival.min = 1000.0
inter_arrival.max = 10000.0
# For normal: mean and std_dev
inter_arrival.mean = 5000.0
inter_arrival.std_dev = 1000.0
# For fixed: value
inter_arrival.value = 5000.0

# tables per transaction (zipf distribution)
ntable.zipf = 2.0
# which tables are selected; (0 most likely, so on)
seltbl.zipf = 1.4
# number of tables written (subset read)
seltblw.zipf = 1.2

# Conflict resolution configuration
# Probability that a conflict is "real" (requires manifest file operations)
# 0.0 = all false conflicts (version changed, no data overlap)
# 1.0 = all real conflicts (overlapping data changes)
real_conflict_probability = 0.0

# For real conflicts: distribution of number of manifest files needing merge
# distribution: "fixed", "exponential", "uniform"
conflicting_manifests.distribution = "exponential"
conflicting_manifests.mean = 3.0      # Mean for exponential distribution
conflicting_manifests.min = 1         # Minimum number of conflicting manifests
conflicting_manifests.max = 10        # Maximum number of conflicting manifests
conflicting_manifests.value = 3       # Value for fixed distribution

[storage]
# Parallelism limit for manifest operations during conflict resolution
max_parallel = 4

# Minimum latency for any storage operation (ms) - prevents unrealistic zero latencies
min_latency = 5

# CAS operation latency (ms) - normal distribution
T_CAS.mean = 100
T_CAS.stddev = 10

# Metadata root read/write latency (ms) - normal distribution
T_METADATA_ROOT.read.mean = 100
T_METADATA_ROOT.read.stddev = 10
T_METADATA_ROOT.write.mean = 120
T_METADATA_ROOT.write.stddev = 15

# Manifest list read/write latency (ms) - normal distribution
T_MANIFEST_LIST.read.mean = 100
T_MANIFEST_LIST.read.stddev = 10
T_MANIFEST_LIST.write.mean = 120
T_MANIFEST_LIST.write.stddev = 15

# Manifest file read/write latency (ms) - normal distribution
T_MANIFEST_FILE.read.mean = 100
T_MANIFEST_FILE.read.stddev = 10
T_MANIFEST_FILE.write.mean = 120
T_MANIFEST_FILE.write.stddev = 15