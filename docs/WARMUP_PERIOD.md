# Warmup Period Analysis

## Overview

Steady-state simulation analysis requires excluding the initial **warmup period** where the system exhibits transient behavior that is not representative of long-term performance.

## Why Warmup Periods Matter

Early simulation periods are unrepresentative because:

1. **Empty start**: No transactions in flight initially
2. **Low contention**: First transactions see artificially low conflict rates
3. **Queue buildup**: System hasn't reached steady-state concurrency
4. **Transient behavior**: Metrics haven't stabilized

Without warmup filtering, performance metrics are biased:
- **Throughput**: Artificially high early (no contention)
- **Latency**: Artificially low early (no queuing)
- **Success rate**: Artificially high early (no conflicts)

## Chosen Approach: Transaction-Runtime Multiple

### Formula

```python
warmup_ms = max(
    5 * 60 * 1000,  # Floor: 5 minutes absolute minimum
    min(
        3 * mean_transaction_runtime,  # 3 transaction cycles
        15 * 60 * 1000  # Ceiling: 15 minutes maximum
    )
)
```

### Rationale

**Steady-state requires multiple transaction lifecycles:**
- Concurrency level ≈ runtime / inter_arrival
- Need time for queue to fill to steady-state depth
- K=3 cycles allows contention to stabilize

**For our baseline configs** (mean_runtime = 180s = 3 minutes):
- Warmup = 3 × 180s = **540 seconds = 9 minutes**
- Clamped to [5min, 15min] → **9 minutes** ✓

**For 1-hour simulations:**
- Warmup: 9 minutes (15%)
- Active window: 51 minutes (85%)
- Plenty of steady-state data

### Validation

See validation plots generated by:
```bash
python -m endive.warmup_validation experiments/exp2_1_*/<seed_dir>
```

Example results for high-load experiment (inter_arrival=20ms):

| Metric | Warmup Period | Active Period | Change |
|--------|---------------|---------------|---------|
| Throughput | 20.8 commits/sec | 16.6 commits/sec | -20.2% |
| Success Rate | 40.9% | 35.8% | -12.5% |
| Mean Latency | 41.5s | 39.1s | -5.8% |

**Conclusion:** 9-minute warmup successfully eliminates initial transient behavior.

## Alternative Approaches Considered

### 1. Static Time Cutoff
```python
warmup_ms = 5 * 60 * 1000  # Always 5 minutes
```

**Pros:** Simple, deterministic
**Cons:** Not adaptive to workload characteristics

### 2. Multiple of Inter-Arrival Time
```python
warmup_ms = 100 * inter_arrival_scale
```

**Pros:** Scales with offered load
**Cons:** Doesn't account for transaction duration (critical flaw)

### 3. Skip First N Transactions
```python
active_window = txn_id >= N
```

**Pros:** Process-based threshold
**Cons:** Poor comparability (different wall-clock times)

### 4. Convergence Detection
Monitor metrics in sliding windows, detect stability.

**Pros:** Theoretically optimal
**Cons:** Complex, non-deterministic, may not converge

## Implementation

### Analysis Scripts

The warmup filter is automatically applied in `endive/saturation_analysis.py`:

```python
def load_and_aggregate_results(exp_info: Dict) -> pd.DataFrame:
    # Compute warmup duration
    warmup_ms = compute_warmup_duration(exp_info['config'])

    # Filter transactions
    df = df[df['t_submit'] >= warmup_ms].copy()

    return df
```

### Validation Script

`endive/warmup_validation.py` generates diagnostic plots:

```bash
# Validate warmup period for an experiment
python -m endive.warmup_validation experiments/exp2_1_*/12345

# Outputs:
# - Convergence analysis statistics
# - Plots showing metrics over time
# - Warmup end marked with red line
```

## Impact on Results

Applying the warmup filter:

1. **Excludes 15-17% of transactions** (first 9 minutes of 1-hour simulation)
2. **Retains 83-85% of data** for steady-state analysis
3. **Improves metric stability** (reduces coefficient of variation)
4. **Ensures comparability** across all configurations

### Example Impact

For a saturated single-table experiment:

- **Before warmup filter:**
  - Total transactions: 170,804
  - Throughput: 47.8 commits/sec (biased high)

- **After warmup filter:**
  - Total transactions: 143,254 (16% excluded)
  - Throughput: 40.3 commits/sec (steady-state)

## Usage in Analysis

All analysis commands automatically apply the warmup filter:

```bash
# Standard analysis (warmup applied automatically)
python -m endive.saturation_analysis \
    -i experiments \
    -p "exp2_1_*" \
    -o plots/exp2_1

# Output shows warmup statistics:
# Processing exp2_1_*... (warmup: 540s, excluded 54255/338573 txns = 16.0%)
```

## Validation Commands

```bash
# Validate single experiment
python -m endive.warmup_validation experiments/exp2_1_*/12345

# Validate with custom window size
python -m endive.warmup_validation experiments/exp2_1_*/12345 --window-size 30

# Save plot to custom location
python -m endive.warmup_validation experiments/exp2_1_*/12345 -o my_validation.png
```

## Key Takeaways

✅ **Use transaction-runtime multiple** (3 cycles, 9 minutes for our configs)
✅ **Clamp to reasonable bounds** [5min, 15min]
✅ **Validate with convergence plots** before trusting results
✅ **Document warmup approach** for reproducibility
✅ **Apply consistently** across all experiments for comparability

## References

- Validation script: `endive/warmup_validation.py`
- Analysis implementation: `endive/saturation_analysis.py`
- Example validation plots: See `warmup_*.png` files
