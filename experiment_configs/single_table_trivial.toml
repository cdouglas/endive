# Single Table, Trivial Conflicts
#
# Blog Question 1a: If the catalog is impossibly fast, how quickly can we
# commit transactions to a single table with only trivial conflicts?
#
# Trivial conflicts require:
# - Read table metadata (JSON blob ~1-10 KB)
# - Read manifest lists for missed snapshots
# - Write merged manifest list
# - Write updated table metadata
#
# Sweep inter_arrival.scale: [10, 20, 50, 100, 200, 500, 1000, 2000, 5000]
# Lower values = higher arrival rate = more contention

[simulation]
duration_ms = 3600000  # 1 hour
output_path = "results.parquet"

[experiment]
label = "single_table_trivial"

[catalog]
num_tables = 1
num_groups = 1
table_metadata_inlined = false  # Model table metadata I/O separately

[transaction]
retry = 10
runtime.min = 30000    # 30 seconds minimum
runtime.mean = 180000  # 3 minutes mean
runtime.sigma = 1.5

inter_arrival.distribution = "exponential"
inter_arrival.scale = 100.0  # SWEEP THIS: [10, 20, 50, 100, 200, 500, 1000, 2000, 5000]

# All conflicts are trivial (no data overlap)
real_conflict_probability = 0.0

# For real conflicts (not used here)
conflicting_manifests.distribution = "exponential"
conflicting_manifests.mean = 3.0
conflicting_manifests.min = 1
conflicting_manifests.max = 10

[storage]
provider = "s3"  # Realistic S3 latencies with size-based PUT model
max_parallel = 4
min_latency = 1

# Use size-based latency from provider profile:
# - Table metadata (~10KB): ~30ms base + negligible size
# - Manifest list (~10-100KB): ~30ms base + negligible size
# - CAS: ~23ms median (lognormal)
