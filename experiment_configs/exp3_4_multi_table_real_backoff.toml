# Experiment 3.4: Multi-Table Real Conflicts with Exponential Backoff
#
# Research Question 4b: Does backoff help with multi-table real conflicts?
#
# Comparison with Exp 3.3:
# - Same setup: multi-table, real conflicts, table-level isolation
# - NEW: Exponential backoff on retry (10ms base, 2x multiplier, 5s max)
#
# Key Insight:
# P(≥1 real conflict in multi-table txn) = 1 - (1 - p)^n_tables
# Real conflicts are expensive (~400ms+), backoff may reduce retry storms
#
# Example: With p=0.3 and 3 tables per transaction:
#   P(≥1 real conflict) = 1 - (1 - 0.3)^3 = 1 - 0.343 = 65.7%
#
# Expected Results:
# - Backoff may be MORE beneficial with real conflicts (expensive retries)
# - Success rate improvements may be larger than exp4.1 (false conflicts)
# - Trade-off: backoff delay vs conflict resolution cost
#
# How to Run:
# Sweep num_tables, real_conflict_probability, and inter_arrival.scale:
#   num_tables = [1, 2, 5, 10, 20]
#   real_conflict_probability = [0.0, 0.1, 0.3, 0.5]
#   inter_arrival.scale = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000]
#
# IMPORTANT: Set num_groups = num_tables for table-level conflicts
#
# For each combination, run multiple seeds:
#   python -m icecap.main experiment_configs/exp3_4_multi_table_real_backoff.toml

[simulation]
duration_ms = 3600000  # 1 hour (matches baseline for comparison)
output_path = "results.parquet"
# seed = 42  # Uncomment to set specific seed, or leave unset for random

[experiment]
label = "exp3_4_multi_table_real_backoff"

[catalog]
# **SWEEP THIS PARAMETER** to study scaling with table count
num_tables = 10  # MODIFY THIS: 1, 2, 5, 10, 20

# IMPORTANT: Set num_groups = num_tables for table-level conflicts
num_groups = 10  # MODIFY THIS: must equal num_tables

[transaction]
retry = 10

# Transaction runtime (lognormal distribution)
# Realistic Iceberg transaction durations: 30s minimum, 3min mean (matches baseline)
runtime.min = 30000   # 30 seconds
runtime.mean = 180000  # 3 minutes
runtime.sigma = 1.5

# Inter-arrival time distribution
# **SWEEP THIS PARAMETER** to vary offered load
inter_arrival.distribution = "exponential"
inter_arrival.scale = 500.0  # ~2 txn/sec (MODIFY THIS FOR LOAD SWEEP)

# Multi-table workload: transactions access 2-3 tables on average
ntable.zipf = 1.5  # Lower = more tables per transaction
seltbl.zipf = 1.4  # Which tables selected (lower = more uniform)
seltblw.zipf = 1.2  # Tables written vs read

# Conflict resolution: VARIABLE REAL CONFLICT PROBABILITY
# **SWEEP THIS PARAMETER** to study interaction with backoff
real_conflict_probability = 0.3  # MODIFY THIS: 0.0, 0.1, 0.3, 0.5

# Distribution of conflicting manifest files (for real conflicts)
conflicting_manifests.distribution = "exponential"
conflicting_manifests.mean = 3.0  # Mean number of manifest files to merge
conflicting_manifests.min = 1
conflicting_manifests.max = 10

# ===== EXPONENTIAL BACKOFF =====
# Retry backoff to reduce wasted CAS attempts under high contention
# Particularly important with real conflicts (expensive resolution)
retry_backoff.enabled = true
retry_backoff.base_ms = 10.0        # Start with 10ms delay
retry_backoff.multiplier = 2.0      # Double each retry: 10, 20, 40, 80, 160, ...
retry_backoff.max_ms = 5000.0       # Cap at 5 seconds
retry_backoff.jitter = 0.1          # ±10% randomization to avoid thundering herd

[storage]
# Parallelism limit for manifest operations during conflict resolution
max_parallel = 4

# Minimum latency for any storage operation (ms)
min_latency = 1

# ===== INFINITELY FAST CATALOG =====
# Near-instant catalog operations to isolate conflict resolution costs
T_CAS.mean = 1
T_CAS.stddev = 0.1

T_METADATA_ROOT.read.mean = 1
T_METADATA_ROOT.read.stddev = 0.1
T_METADATA_ROOT.write.mean = 1
T_METADATA_ROOT.write.stddev = 0.1

# ===== REALISTIC STORAGE LATENCIES =====
# Typical S3 performance
T_MANIFEST_LIST.read.mean = 50
T_MANIFEST_LIST.read.stddev = 5
T_MANIFEST_LIST.write.mean = 60
T_MANIFEST_LIST.write.stddev = 6

T_MANIFEST_FILE.read.mean = 50
T_MANIFEST_FILE.read.stddev = 5
T_MANIFEST_FILE.write.mean = 60
T_MANIFEST_FILE.write.stddev = 6
