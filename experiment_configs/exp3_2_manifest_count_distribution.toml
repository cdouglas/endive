# Experiment 3.2: Conflicting Manifest Count Distribution
#
# Research Question 1b (continued): Show how variance in conflict cost affects saturation
#
# Setup:
# - Single table with catalog-level conflicts
# - Fixed real conflict probability (50%)
# - Variable distribution of conflicting manifest files
# - Infinitely fast catalog (T_CAS = 1ms, T_METADATA_ROOT = 1ms)
# - Realistic storage latencies for manifest lists/files
#
# Purpose:
# Compare impact of different distributions of conflicting manifest files:
# - Fixed small (1 file): Best case for real conflicts
# - Fixed medium (5 files): Typical case
# - Fixed large (10 files): Worst case
# - Exponential (mean=3): Realistic variance (most conflicts small, occasional large)
#
# Expected Results:
# - Fixed distributions show clear cost differences
# - Exponential distribution shows impact of variance
# - Higher mean conflicting manifests â†’ lower saturation point
#
# How to Run:
# Sweep conflicting_manifests configuration and inter_arrival.scale:
#
# Distributions to test:
#   1. distribution="fixed", value=1     (best case)
#   2. distribution="fixed", value=5     (typical)
#   3. distribution="fixed", value=10    (worst case)
#   4. distribution="exponential", mean=3, min=1, max=20  (realistic)
#   5. distribution="uniform", min=1, max=10  (uniform variance)
#
#   inter_arrival.scale = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000]
#
# For each configuration, run multiple seeds:
#   python -m icecap.main experiment_configs/exp3_2_manifest_count_distribution.toml

[simulation]
duration_ms = 100000  # 100 seconds
output_path = "results.parquet"
# seed = 42  # Uncomment to set specific seed, or leave unset for random

[experiment]
label = "exp3_2_manifest_distribution"

[catalog]
num_tables = 1
num_groups = 1  # Catalog-level conflicts

[transaction]
retry = 10

# Transaction runtime (lognormal distribution)
runtime.min = 5000
runtime.mean = 10000
runtime.sigma = 1.5

# Inter-arrival time distribution
# **SWEEP THIS PARAMETER** to vary offered load
inter_arrival.distribution = "exponential"
inter_arrival.scale = 500.0  # ~2 txn/sec (MODIFY THIS FOR LOAD SWEEP)

# Simple workload: single table access
ntable.zipf = 10.0  # Ensure exactly 1 table per txn
seltbl.zipf = 1.4
seltblw.zipf = 1.2

# Conflict resolution: 50% real conflicts
real_conflict_probability = 0.5  # Fixed at 50% to isolate distribution effect

# **SWEEP THESE PARAMETERS** to study impact of conflicting manifest distribution
# Option 1: Fixed small
conflicting_manifests.distribution = "fixed"
conflicting_manifests.value = 1

# Option 2: Fixed medium (uncomment to use)
# conflicting_manifests.distribution = "fixed"
# conflicting_manifests.value = 5

# Option 3: Fixed large (uncomment to use)
# conflicting_manifests.distribution = "fixed"
# conflicting_manifests.value = 10

# Option 4: Exponential (uncomment to use)
# conflicting_manifests.distribution = "exponential"
# conflicting_manifests.mean = 3.0
# conflicting_manifests.min = 1
# conflicting_manifests.max = 20

# Option 5: Uniform (uncomment to use)
# conflicting_manifests.distribution = "uniform"
# conflicting_manifests.min = 1
# conflicting_manifests.max = 10

[storage]
# Parallelism limit for manifest operations during conflict resolution
max_parallel = 4

# Minimum latency for any storage operation (ms)
min_latency = 1

# ===== INFINITELY FAST CATALOG =====
# Near-instant catalog operations to isolate conflict resolution costs
T_CAS.mean = 1
T_CAS.stddev = 0.1

T_METADATA_ROOT.read.mean = 1
T_METADATA_ROOT.read.stddev = 0.1
T_METADATA_ROOT.write.mean = 1
T_METADATA_ROOT.write.stddev = 0.1

# ===== REALISTIC STORAGE LATENCIES =====
# Typical S3 performance
T_MANIFEST_LIST.read.mean = 50
T_MANIFEST_LIST.read.stddev = 5
T_MANIFEST_LIST.write.mean = 60
T_MANIFEST_LIST.write.stddev = 6

T_MANIFEST_FILE.read.mean = 50
T_MANIFEST_FILE.read.stddev = 5
T_MANIFEST_FILE.write.mean = 60
T_MANIFEST_FILE.write.stddev = 6
